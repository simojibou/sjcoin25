<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pro Studio: Real-Time FX</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/lucide@latest"></script>
    <!-- LameJS for MP3 Encoding -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/lamejs/1.2.1/lame.min.js"></script>
    <style>
        /* Pro Dark Theme Styles */
        body { background-color: #0f172a; color: #e2e8f0; }
        
        ::-webkit-scrollbar { width: 6px; height: 6px; }
        ::-webkit-scrollbar-track { background: #1e293b; }
        ::-webkit-scrollbar-thumb { background: #475569; border-radius: 3px; }
        
        .glass-panel {
            background: rgba(30, 41, 59, 0.7);
            backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .knob-range {
            -webkit-appearance: none;
            height: 4px;
            background: #334155;
            border-radius: 2px;
            outline: none;
        }
        .knob-range::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            background: #3b82f6;
            border-radius: 50%;
            cursor: pointer;
            transition: transform 0.1s;
        }
        .knob-range::-webkit-slider-thumb:hover { transform: scale(1.2); }

        .processing-active { animation: pulse-glow 2s infinite; border-color: #3b82f6; }
        @keyframes pulse-glow {
            0%, 100% { box-shadow: 0 0 5px rgba(59, 130, 246, 0.5); }
            50% { box-shadow: 0 0 20px rgba(59, 130, 246, 0.8); }
        }

        /* Play button pulse when playing */
        .playing-pulse {
            animation: pulse-green 2s infinite;
        }
        @keyframes pulse-green {
            0% { box-shadow: 0 0 0 0 rgba(34, 197, 94, 0.4); }
            70% { box-shadow: 0 0 0 10px rgba(34, 197, 94, 0); }
            100% { box-shadow: 0 0 0 0 rgba(34, 197, 94, 0); }
        }
    </style>
</head>
<body class="flex flex-col min-h-screen font-sans selection:bg-blue-500 selection:text-white">

    <!-- Navbar -->
    <nav class="sticky top-0 z-50 glass-panel border-b-0 border-b border-gray-700">
        <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
            <div class="flex items-center justify-between h-16">
                <div class="flex items-center gap-3">
                    <div class="bg-gradient-to-br from-blue-500 to-indigo-600 p-2 rounded-lg shadow-lg">
                        <i data-lucide="waves" class="text-white w-6 h-6"></i>
                    </div>
                    <div>
                        <h1 class="text-xl font-bold bg-clip-text text-transparent bg-gradient-to-r from-blue-400 to-indigo-400">VibeStudio Pro</h1>
                        <p class="text-[10px] text-gray-400 uppercase tracking-widest font-semibold">Real-Time FX Engine</p>
                    </div>
                </div>
                <div class="flex gap-4">
                    <button onclick="switchMode('studio')" id="nav-studio" class="text-blue-400 font-medium hover:text-white transition">Studio</button>
                    <button onclick="switchMode('art')" id="nav-art" class="text-gray-400 font-medium hover:text-white transition">Cover Art</button>
                </div>
            </div>
        </div>
    </nav>

    <!-- Main Content -->
    <main class="flex-grow p-4 md:p-6 max-w-7xl mx-auto w-full gap-6 grid grid-cols-1 lg:grid-cols-12">

        <!-- ================= STUDIO MODE ================= -->
        
        <!-- Sidebar: Effects Rack (Left) -->
        <aside id="effects-rack" class="lg:col-span-3 glass-panel rounded-2xl p-5 space-y-6 h-fit lg:sticky lg:top-24">
            <div class="flex items-center gap-2 mb-2">
                <i data-lucide="sliders" class="w-5 h-5 text-blue-400"></i>
                <h2 class="text-lg font-bold">Live FX Rack</h2>
            </div>
            
            <!-- Slow & Reverb Control -->
            <div class="space-y-4">
                <div class="flex justify-between items-center">
                    <label class="text-sm font-semibold text-gray-300">Speed (Slow)</label>
                    <span id="speed-val" class="text-xs font-mono text-blue-400">100%</span>
                </div>
                <input type="range" id="speed-slider" min="50" max="120" value="100" class="knob-range w-full" oninput="updateLiveParams()">
                <p class="text-xs text-gray-500">Updates in real-time while playing.</p>
                
                <div class="flex justify-between items-center mt-4">
                    <label class="text-sm font-semibold text-gray-300">Reverb (Space)</label>
                    <span id="reverb-val" class="text-xs font-mono text-blue-400">0%</span>
                </div>
                <input type="range" id="reverb-slider" min="0" max="100" value="0" class="knob-range w-full" oninput="updateLiveParams()">
            </div>

            <hr class="border-gray-700">

            <!-- 3-Band EQ -->
            <div>
                <div class="flex justify-between items-center mb-4">
                    <label class="text-sm font-semibold text-gray-300">Master EQ</label>
                    <button onclick="resetEQ()" class="text-xs text-gray-500 hover:text-white">Reset</button>
                </div>
                <div class="flex justify-between px-2">
                    <div class="flex flex-col items-center gap-2">
                        <input type="range" id="eq-high" min="-12" max="12" value="0" orient="vertical" class="h-24 w-1 bg-gray-700 rounded-full appearance-none cursor-pointer [&::-webkit-slider-thumb]:appearance-none [&::-webkit-slider-thumb]:w-4 [&::-webkit-slider-thumb]:h-4 [&::-webkit-slider-thumb]:rounded-full [&::-webkit-slider-thumb]:bg-blue-500" oninput="updateLiveParams()">
                        <span class="text-xs text-gray-400">Hi</span>
                    </div>
                    <div class="flex flex-col items-center gap-2">
                        <input type="range" id="eq-mid" min="-12" max="12" value="0" orient="vertical" class="h-24 w-1 bg-gray-700 rounded-full appearance-none cursor-pointer [&::-webkit-slider-thumb]:appearance-none [&::-webkit-slider-thumb]:w-4 [&::-webkit-slider-thumb]:h-4 [&::-webkit-slider-thumb]:rounded-full [&::-webkit-slider-thumb]:bg-emerald-500" oninput="updateLiveParams()">
                        <span class="text-xs text-gray-400">Mid</span>
                    </div>
                    <div class="flex flex-col items-center gap-2">
                        <input type="range" id="eq-low" min="-12" max="12" value="0" orient="vertical" class="h-24 w-1 bg-gray-700 rounded-full appearance-none cursor-pointer [&::-webkit-slider-thumb]:appearance-none [&::-webkit-slider-thumb]:w-4 [&::-webkit-slider-thumb]:h-4 [&::-webkit-slider-thumb]:rounded-full [&::-webkit-slider-thumb]:bg-indigo-500" oninput="updateLiveParams()">
                        <span class="text-xs text-gray-400">Low</span>
                    </div>
                </div>
            </div>

            <hr class="border-gray-700">

            <!-- Output Format -->
             <div class="space-y-4">
                <h3 class="text-sm font-bold text-gray-200 flex items-center gap-2">
                    <i data-lucide="settings-2" class="w-4 h-4"></i> Output Settings
                </h3>

                <!-- Format -->
                <div>
                    <label class="text-xs text-gray-400 block mb-1">File Format</label>
                    <select id="export-format" onchange="toggleBitrate()" class="w-full bg-gray-800 border border-gray-600 rounded-lg p-2 text-sm text-white focus:ring-1 focus:ring-blue-500 outline-none">
                        <option value="mp3">MP3 (Compressed)</option>
                        <option value="wav">WAV (Lossless)</option>
                    </select>
                </div>

                <!-- Sample Rate -->
                <div>
                    <label class="text-xs text-gray-400 block mb-1">Sample Rate (Hz)</label>
                    <select id="sample-rate" class="w-full bg-gray-800 border border-gray-600 rounded-lg p-2 text-sm text-white focus:ring-1 focus:ring-blue-500 outline-none">
                        <option value="44100" selected>44100 Hz (Music)</option>
                        <option value="48000">48000 Hz (Video)</option>
                    </select>
                </div>

                <!-- Bitrate (MP3 Only) -->
                <div id="bitrate-container">
                    <label class="text-xs text-gray-400 block mb-1">Bitrate (kbps)</label>
                    <select id="bitrate" class="w-full bg-gray-800 border border-gray-600 rounded-lg p-2 text-sm text-white focus:ring-1 focus:ring-blue-500 outline-none">
                        <option value="320" selected>320 kbps (High Quality)</option>
                        <option value="192">192 kbps (Standard)</option>
                        <option value="128">128 kbps (Low)</option>
                    </select>
                </div>
            </div>
        </aside>

        <!-- Main Workspace: Track List (Center) -->
        <section id="studio-main" class="lg:col-span-9 space-y-6">
            
            <!-- Upload Area -->
            <div id="drop-zone" class="glass-panel border-2 border-dashed border-gray-600 rounded-2xl h-48 flex flex-col items-center justify-center cursor-pointer hover:border-blue-500 hover:bg-gray-800/50 transition-all group relative overflow-hidden">
                <div class="absolute inset-0 bg-blue-500/5 opacity-0 group-hover:opacity-100 transition-opacity pointer-events-none"></div>
                <input type="file" id="file-input" multiple accept="audio/*" class="hidden">
                <div class="p-4 bg-gray-800 rounded-full mb-3 shadow-xl group-hover:scale-110 transition-transform">
                    <i data-lucide="layers" class="w-8 h-8 text-blue-400"></i>
                </div>
                <h3 class="text-xl font-bold text-gray-200">Drop Tracks Here</h3>
                <p class="text-gray-400 text-sm mt-1">Batch process 10+ tracks at once</p>
            </div>

            <!-- Queue Actions -->
            <div id="queue-actions" class="hidden flex justify-between items-center bg-gray-800/50 p-4 rounded-xl border border-gray-700">
                <div class="flex items-center gap-3">
                    <span class="text-gray-300 font-medium" id="track-count">0 Tracks Loaded</span>
                    <button onclick="clearQueue()" class="text-xs text-red-400 hover:underline">Clear All</button>
                </div>
                <button onclick="processBatch()" id="btn-process" class="bg-gradient-to-r from-blue-600 to-indigo-600 hover:from-blue-500 hover:to-indigo-500 text-white font-bold py-2 px-6 rounded-lg shadow-lg shadow-blue-900/40 flex items-center gap-2 transition-all active:scale-95">
                    <i data-lucide="zap" class="w-4 h-4"></i>
                    <span>Apply Effects & Convert All</span>
                </button>
            </div>

            <!-- Track List -->
            <div id="track-list" class="space-y-3">
                <!-- Tracks inject here -->
            </div>

        </section>

        <!-- ================= ART MODE (Hidden) ================= -->
        <section id="art-main" class="hidden lg:col-span-12 grid grid-cols-1 md:grid-cols-2 gap-8">
             <div class="glass-panel p-6 rounded-2xl">
                <h2 class="text-xl font-bold mb-4">Cover Art Generator</h2>
                <div class="space-y-4">
                    <button onclick="document.getElementById('art-file').click()" class="w-full py-3 bg-gray-700 rounded-lg hover:bg-gray-600 transition flex items-center justify-center gap-2">
                        <i data-lucide="image-plus" class="w-4 h-4"></i> Upload Background
                    </button>
                    <input type="file" id="art-file" class="hidden" accept="image/*">
                    
                    <input type="text" id="art-artist" placeholder="Artist Name" class="w-full bg-gray-800 border border-gray-600 rounded-lg p-3 text-white">
                    <input type="text" id="art-song" placeholder="Song/Album Title" class="w-full bg-gray-800 border border-gray-600 rounded-lg p-3 text-white">
                    
                    <div class="grid grid-cols-2 gap-4">
                        <button onclick="downloadArt()" class="col-span-2 bg-green-600 hover:bg-green-500 text-white font-bold py-3 rounded-lg shadow-lg">Download 3000px</button>
                    </div>
                </div>
            </div>
            <div class="flex justify-center items-start">
                <canvas id="art-preview" class="w-full max-w-md aspect-square bg-gray-900 rounded-lg shadow-2xl border border-gray-700"></canvas>
                <canvas id="art-hd" width="3000" height="3000" class="hidden"></canvas>
            </div>
        </section>

    </main>

    <!-- Global Scripts -->
    <script>
        lucide.createIcons();

        // --- GLOBAL VARIABLES ---
        let audioCtx;
        const trackQueue = []; // Array of { id, file, status, buffer, blob }
        let isProcessing = false;
        
        // --- LIVE AUDIO GRAPH ---
        const liveAudio = {
            source: null,
            dryNode: null,
            wetNode: null,
            convolver: null,
            filters: { low: null, mid: null, high: null },
            isPlaying: false,
            currentId: null,
            impulseBuffer: null
        };

        // --- UI SWITCHING ---
        function switchMode(mode) {
            const studio = document.getElementById('studio-main');
            const rack = document.getElementById('effects-rack');
            const art = document.getElementById('art-main');
            const btnStudio = document.getElementById('nav-studio');
            const btnArt = document.getElementById('nav-art');

            if(mode === 'studio') {
                studio.classList.remove('hidden');
                rack.classList.remove('hidden');
                art.classList.add('hidden');
                btnStudio.classList.add('text-blue-400');
                btnStudio.classList.remove('text-gray-400');
                btnArt.classList.remove('text-blue-400');
            } else {
                studio.classList.add('hidden');
                rack.classList.add('hidden');
                art.classList.remove('hidden');
                btnStudio.classList.remove('text-blue-400');
                btnArt.classList.add('text-blue-400');
                renderArt(); 
            }
        }

        function toggleBitrate() {
            const format = document.getElementById('export-format').value;
            const container = document.getElementById('bitrate-container');
            if (format === 'wav') {
                container.classList.add('opacity-50', 'pointer-events-none');
            } else {
                container.classList.remove('opacity-50', 'pointer-events-none');
            }
        }

        // --- DRAG & DROP & FILE HANDLING ---
        const dropZone = document.getElementById('drop-zone');
        const fileInput = document.getElementById('file-input');

        dropZone.addEventListener('click', () => fileInput.click());
        dropZone.addEventListener('dragover', (e) => { e.preventDefault(); dropZone.classList.add('border-blue-500', 'bg-gray-800/80'); });
        dropZone.addEventListener('dragleave', (e) => { e.preventDefault(); dropZone.classList.remove('border-blue-500', 'bg-gray-800/80'); });
        dropZone.addEventListener('drop', (e) => {
            e.preventDefault();
            dropZone.classList.remove('border-blue-500', 'bg-gray-800/80');
            handleFiles(e.dataTransfer.files);
        });
        fileInput.addEventListener('change', (e) => handleFiles(e.target.files));

        function handleFiles(files) {
            const list = document.getElementById('track-list');
            const actions = document.getElementById('queue-actions');

            if (files.length > 0) actions.classList.remove('hidden');

            Array.from(files).forEach(file => {
                if(!file.type.startsWith('audio/')) return;

                const id = Math.random().toString(36).substr(2, 9);
                const trackObj = { id, file, status: 'pending', buffer: null };
                trackQueue.push(trackObj);

                const el = document.createElement('div');
                el.id = `track-${id}`;
                el.className = "glass-panel p-4 rounded-xl flex items-center justify-between animate-fade-in transition-all";
                el.innerHTML = `
                    <div class="flex items-center gap-4 min-w-0">
                        <button onclick="togglePreview('${id}')" id="play-btn-${id}" class="w-10 h-10 rounded-full bg-gray-700 hover:bg-gray-600 flex items-center justify-center flex-shrink-0 transition-all">
                            <i data-lucide="play" class="w-4 h-4 text-white fill-current ml-0.5"></i>
                        </button>

                        <div class="min-w-0">
                            <h4 class="font-medium text-white truncate max-w-xs md:max-w-md">${file.name}</h4>
                            <p class="text-xs text-gray-400" id="status-${id}">Ready for FX</p>
                        </div>
                    </div>
                    <div class="flex items-center gap-3">
                        <div id="loader-${id}" class="hidden w-5 h-5 border-2 border-blue-500 border-t-transparent rounded-full animate-spin"></div>
                        <button onclick="downloadTrack('${id}')" id="dl-${id}" class="hidden bg-green-600 hover:bg-green-500 text-white px-3 py-1.5 rounded-lg text-xs font-bold flex items-center gap-1">
                            <i data-lucide="download" class="w-3 h-3"></i> Save
                        </button>
                        <button onclick="removeTrack('${id}')" class="text-gray-500 hover:text-red-400 p-2">
                            <i data-lucide="x" class="w-4 h-4"></i>
                        </button>
                    </div>
                `;
                list.appendChild(el);
            });
            lucide.createIcons();
            updateCount();
        }

        // --- REAL-TIME AUDIO ENGINE ---

        // Initialize Global Audio Context and Graph Nodes
        async function initLiveAudio() {
            if (audioCtx) return;
            audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            
            // Create Nodes
            liveAudio.dryNode = audioCtx.createGain();
            liveAudio.wetNode = audioCtx.createGain();
            liveAudio.convolver = audioCtx.createConvolver();
            
            liveAudio.filters.low = audioCtx.createBiquadFilter();
            liveAudio.filters.low.type = 'lowshelf';
            liveAudio.filters.low.frequency.value = 320;

            liveAudio.filters.mid = audioCtx.createBiquadFilter();
            liveAudio.filters.mid.type = 'peaking';
            liveAudio.filters.mid.frequency.value = 1000;

            liveAudio.filters.high = audioCtx.createBiquadFilter();
            liveAudio.filters.high.type = 'highshelf';
            liveAudio.filters.high.frequency.value = 3200;

            // Generate Impulse for Reverb
            liveAudio.impulseBuffer = await generateImpulseResponse(audioCtx, 2.5);
            liveAudio.convolver.buffer = liveAudio.impulseBuffer;

            // Connect Filters: Source -> Low -> Mid -> High
            // We connect Source later.
            // High -> Split to Dry/Wet
        }

        async function togglePreview(id) {
            await initLiveAudio();

            // Stop current if playing
            if (liveAudio.currentId === id && liveAudio.isPlaying) {
                stopLivePlayback();
                return;
            }
            if (liveAudio.currentId && liveAudio.currentId !== id) {
                stopLivePlayback();
            }

            const track = trackQueue.find(t => t.id === id);
            if (!track) return;

            // UI Update to Loading
            const btn = document.getElementById(`play-btn-${id}`);
            btn.innerHTML = `<div class="w-4 h-4 border-2 border-white border-t-transparent rounded-full animate-spin"></div>`;

            // Decode if needed
            if (!track.buffer) {
                try {
                    const arrayBuffer = await track.file.arrayBuffer();
                    track.buffer = await audioCtx.decodeAudioData(arrayBuffer);
                } catch(e) {
                    console.error("Decode error", e);
                    btn.innerHTML = `<i data-lucide="alert-circle" class="w-4 h-4 text-red-500"></i>`;
                    return;
                }
            }

            // Setup Source
            liveAudio.source = audioCtx.createBufferSource();
            liveAudio.source.buffer = track.buffer;
            liveAudio.source.loop = true; // Loop for easier tweaking

            // Build Graph: Source -> Low -> Mid -> High -> Dry/Convolver -> Dest
            liveAudio.source.connect(liveAudio.filters.low);
            liveAudio.filters.low.connect(liveAudio.filters.mid);
            liveAudio.filters.mid.connect(liveAudio.filters.high);

            liveAudio.filters.high.connect(liveAudio.dryNode);
            liveAudio.filters.high.connect(liveAudio.convolver);
            
            liveAudio.convolver.connect(liveAudio.wetNode);
            
            liveAudio.dryNode.connect(audioCtx.destination);
            liveAudio.wetNode.connect(audioCtx.destination);

            // Apply Current Params
            updateLiveParams();

            // Start
            liveAudio.source.start(0);
            liveAudio.isPlaying = true;
            liveAudio.currentId = id;

            // UI Update to Playing
            updatePlayIcon(id, true);
        }

        function stopLivePlayback() {
            if (liveAudio.source) {
                try { liveAudio.source.stop(); } catch(e){}
                liveAudio.source.disconnect();
            }
            if(liveAudio.currentId) {
                updatePlayIcon(liveAudio.currentId, false);
            }
            liveAudio.isPlaying = false;
            liveAudio.currentId = null;
        }

        function updateLiveParams() {
            if (!audioCtx) return;

            // Slider Values
            const speed = parseInt(document.getElementById('speed-slider').value);
            const reverb = parseInt(document.getElementById('reverb-slider').value);
            const high = parseInt(document.getElementById('eq-high').value);
            const mid = parseInt(document.getElementById('eq-mid').value);
            const low = parseInt(document.getElementById('eq-low').value);

            // Update UI Labels
            document.getElementById('speed-val').textContent = speed + '%';
            document.getElementById('reverb-val').textContent = reverb + '%';

            // Update Audio Nodes
            if (liveAudio.source) {
                // Smooth transition for pitch/speed to prevent clicks
                liveAudio.source.playbackRate.setTargetAtTime(speed / 100, audioCtx.currentTime, 0.1);
            }

            if (liveAudio.dryNode && liveAudio.wetNode) {
                const reverbAmt = reverb / 100;
                liveAudio.dryNode.gain.setTargetAtTime(1.0 - (reverbAmt * 0.4), audioCtx.currentTime, 0.1);
                liveAudio.wetNode.gain.setTargetAtTime(reverbAmt, audioCtx.currentTime, 0.1);
            }

            if (liveAudio.filters.low) liveAudio.filters.low.gain.setTargetAtTime(low, audioCtx.currentTime, 0.1);
            if (liveAudio.filters.mid) liveAudio.filters.mid.gain.setTargetAtTime(mid, audioCtx.currentTime, 0.1);
            if (liveAudio.filters.high) liveAudio.filters.high.gain.setTargetAtTime(high, audioCtx.currentTime, 0.1);
        }

        function updatePlayIcon(id, isPlaying) {
            const btn = document.getElementById(`play-btn-${id}`);
            if(!btn) return;
            
            if (isPlaying) {
                btn.innerHTML = `<i data-lucide="pause" class="w-4 h-4 text-white fill-current"></i>`;
                btn.classList.add('bg-green-600', 'playing-pulse');
                btn.classList.remove('bg-gray-700', 'hover:bg-gray-600');
            } else {
                btn.innerHTML = `<i data-lucide="play" class="w-4 h-4 text-white fill-current ml-0.5"></i>`;
                btn.classList.remove('bg-green-600', 'playing-pulse');
                btn.classList.add('bg-gray-700', 'hover:bg-gray-600');
            }
            lucide.createIcons();
        }

        function removeTrack(id) {
            if(liveAudio.currentId === id) stopLivePlayback();
            const idx = trackQueue.findIndex(t => t.id === id);
            if(idx > -1) trackQueue.splice(idx, 1);
            document.getElementById(`track-${id}`).remove();
            updateCount();
        }

        function clearQueue() {
            stopLivePlayback();
            trackQueue.length = 0;
            document.getElementById('track-list').innerHTML = '';
            updateCount();
        }

        function updateCount() {
            document.getElementById('track-count').textContent = `${trackQueue.length} Tracks Loaded`;
            if(trackQueue.length === 0) document.getElementById('queue-actions').classList.add('hidden');
        }

        function resetEQ() {
            document.getElementById('eq-high').value = 0;
            document.getElementById('eq-mid').value = 0;
            document.getElementById('eq-low').value = 0;
            updateLiveParams();
        }


        // --- BATCH PROCESSOR (OFFLINE RENDER) ---

        async function processBatch() {
            if(isProcessing) return;
            isProcessing = true;
            document.getElementById('btn-process').disabled = true;
            document.getElementById('btn-process').classList.add('opacity-50');

            await initLiveAudio(); // Ensure context
            stopLivePlayback(); // Stop preview if running

            // Loop through queue
            for(const track of trackQueue) {
                if(track.status === 'done') continue;

                updateTrackStatus(track.id, 'processing');
                
                try {
                    // Decode if not already done by preview
                    if (!track.buffer) {
                        const arrayBuffer = await track.file.arrayBuffer();
                        track.buffer = await audioCtx.decodeAudioData(arrayBuffer);
                    }

                    // Get Settings
                    const speed = parseInt(document.getElementById('speed-slider').value) / 100;
                    const reverbAmt = parseInt(document.getElementById('reverb-slider').value) / 100;
                    const sampleRate = parseInt(document.getElementById('sample-rate').value);
                    const format = document.getElementById('export-format').value;
                    const bitrate = parseInt(document.getElementById('bitrate').value);

                    // Render Offline
                    const renderedBuffer = await renderTrackOffline(track.buffer, speed, reverbAmt, sampleRate);

                    // Encode
                    let blob;
                    if(format === 'mp3') {
                         blob = await encodeMp3(renderedBuffer, sampleRate, bitrate);
                    } else {
                         blob = bufferToWave(renderedBuffer, renderedBuffer.length);
                    }

                    // Store
                    track.blob = blob;
                    track.status = 'done';
                    track.ext = format;

                    updateTrackStatus(track.id, 'done');

                } catch (e) {
                    console.error(e);
                    updateTrackStatus(track.id, 'error');
                }
            }

            isProcessing = false;
            document.getElementById('btn-process').disabled = false;
            document.getElementById('btn-process').classList.remove('opacity-50');
        }

        async function renderTrackOffline(buffer, speed, reverbAmt, sampleRate) {
            // New duration (approx based on speed) + reverb tail
            const newDuration = (buffer.duration / speed) + (reverbAmt > 0 ? 3 : 0);
            
            const offlineCtx = new OfflineAudioContext(2, newDuration * sampleRate, sampleRate);

            // Source
            const source = offlineCtx.createBufferSource();
            source.buffer = buffer;
            source.playbackRate.value = speed;

            // Setup Nodes (Duplicate logic of live graph)
            const low = offlineCtx.createBiquadFilter();
            low.type = 'lowshelf'; low.frequency.value = 320; 
            low.gain.value = parseInt(document.getElementById('eq-low').value);

            const mid = offlineCtx.createBiquadFilter();
            mid.type = 'peaking'; mid.frequency.value = 1000;
            mid.gain.value = parseInt(document.getElementById('eq-mid').value);

            const high = offlineCtx.createBiquadFilter();
            high.type = 'highshelf'; high.frequency.value = 3200;
            high.gain.value = parseInt(document.getElementById('eq-high').value);

            source.connect(low);
            low.connect(mid);
            mid.connect(high);

            if(reverbAmt > 0) {
                const convolver = offlineCtx.createConvolver();
                // Reuse the buffer we generated for live, or regenerate if needed
                // OfflineCtx needs its own buffer usually, but we can reuse the data
                convolver.buffer = liveAudio.impulseBuffer || await generateImpulseResponse(audioCtx, 2.5);
                
                const dry = offlineCtx.createGain();
                const wet = offlineCtx.createGain();
                
                dry.gain.value = 1.0 - (reverbAmt * 0.4);
                wet.gain.value = reverbAmt;

                high.connect(dry);
                high.connect(convolver);
                convolver.connect(wet);

                dry.connect(offlineCtx.destination);
                wet.connect(offlineCtx.destination);
            } else {
                high.connect(offlineCtx.destination);
            }

            source.start(0);
            return await offlineCtx.startRendering();
        }

        async function generateImpulseResponse(ctx, duration) {
            const sampleRate = ctx.sampleRate;
            const length = sampleRate * duration;
            const impulse = ctx.createBuffer(2, length, sampleRate);
            for (let channel = 0; channel < 2; channel++) {
                const impulseData = impulse.getChannelData(channel);
                for (let i = 0; i < length; i++) {
                    impulseData[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / length, 2);
                }
            }
            return impulse;
        }

        // UI Updates
        function updateTrackStatus(id, status) {
            const statusText = document.getElementById(`status-${id}`);
            const loader = document.getElementById(`loader-${id}`);
            const dlBtn = document.getElementById(`dl-${id}`);
            const card = document.getElementById(`track-${id}`);

            if(status === 'processing') {
                statusText.textContent = "Processing...";
                statusText.className = "text-xs text-blue-400 font-bold";
                loader.classList.remove('hidden');
                card.classList.add('processing-active');
            } else if (status === 'done') {
                statusText.textContent = "Processing Complete";
                statusText.className = "text-xs text-green-400 font-medium";
                loader.classList.add('hidden');
                dlBtn.classList.remove('hidden');
                card.classList.remove('processing-active');
                card.classList.add('border', 'border-green-500/30');
            } else if (status === 'error') {
                statusText.textContent = "Error";
                statusText.className = "text-xs text-red-500";
                loader.classList.add('hidden');
                card.classList.remove('processing-active');
            }
        }

        function downloadTrack(id) {
            const track = trackQueue.find(t => t.id === id);
            if(!track || !track.blob) return;
            const url = URL.createObjectURL(track.blob);
            const a = document.createElement('a');
            a.href = url;
            let suffix = parseInt(document.getElementById('speed-slider').value) < 100 ? '_slowed' : '_mastered';
            a.download = `${track.file.name.replace(/\.[^/.]+$/, "")}${suffix}.${track.ext}`;
            a.click();
        }

        // --- ENCODERS (WAV/MP3) ---
        function bufferToWave(abuffer, len) {
            let numOfChan = abuffer.numberOfChannels;
            let length = len * numOfChan * 2 + 44;
            let buffer = new ArrayBuffer(length);
            let view = new DataView(buffer);
            let channels = [], i, sample, offset = 0, pos = 0;
            function setUint16(data) { view.setUint16(offset, data, true); offset += 2; }
            function setUint32(data) { view.setUint32(offset, data, true); offset += 4; }
            setUint32(0x46464952); setUint32(length - 8); setUint32(0x45564157);
            setUint32(0x20746d66); setUint32(16); setUint16(1); setUint16(numOfChan);
            setUint32(abuffer.sampleRate); setUint32(abuffer.sampleRate * 2 * numOfChan);
            setUint16(numOfChan * 2); setUint16(16); setUint32(0x61746164);
            setUint32(length - pos - 4);
            for(i=0; i<numOfChan; i++) channels.push(abuffer.getChannelData(i));
            while(pos < len) {
                for(i=0; i<numOfChan; i++) {
                    sample = Math.max(-1, Math.min(1, channels[i][pos]));
                    sample = (0.5 + sample < 0 ? sample * 32768 : sample * 32767)|0;
                    view.setInt16(offset, sample, true);
                    offset += 2;
                }
                pos++;
            }
            return new Blob([buffer], {type: "audio/wav"});
        }

        async function encodeMp3(buffer, sampleRate, bitrate) {
            const channels = 2;
            const mp3enc = new lamejs.Mp3Encoder(channels, sampleRate, bitrate);
            const blockSize = 1152;
            const left = buffer.getChannelData(0);
            const right = buffer.getChannelData(1);
            const leftInt = new Int16Array(left.length);
            const rightInt = new Int16Array(right.length);
            for (let i = 0; i < left.length; i++) {
                leftInt[i] = left[i] < 0 ? left[i] * 0x8000 : left[i] * 0x7FFF;
                rightInt[i] = right[i] < 0 ? right[i] * 0x8000 : right[i] * 0x7FFF;
            }
            const mp3Data = [];
            for (let i = 0; i < leftInt.length; i += blockSize) {
                const l = leftInt.subarray(i, i + blockSize);
                const r = rightInt.subarray(i, i + blockSize);
                const buf = mp3enc.encodeBuffer(l, r);
                if (buf.length > 0) mp3Data.push(buf);
            }
            const buf = mp3enc.flush();
            if (buf.length > 0) mp3Data.push(buf);
            return new Blob(mp3Data, { type: 'audio/mp3' });
        }


        // --- ART LOGIC ---
        const artCanvas = document.getElementById('art-hd');
        const artPreview = document.getElementById('art-preview');
        const artFile = document.getElementById('art-file');
        let artImg = null;
        artFile.addEventListener('change', (e) => {
             const r = new FileReader();
             r.onload = ev => {
                 const i = new Image();
                 i.onload = () => { artImg = i; renderArt(); };
                 i.src = ev.target.result;
             };
             r.readAsDataURL(e.target.files[0]);
        });
        ['art-artist', 'art-song'].forEach(id => document.getElementById(id).addEventListener('input', renderArt));
        function renderArt() {
            const ctx = artCanvas.getContext('2d');
            ctx.fillStyle = '#0f172a';
            ctx.fillRect(0,0,3000,3000);
            if(artImg) {
                const ratio = Math.max(3000/artImg.width, 3000/artImg.height);
                const cx = (3000 - artImg.width*ratio)/2;
                const cy = (3000 - artImg.height*ratio)/2;
                ctx.drawImage(artImg, 0,0, artImg.width, artImg.height, cx, cy, artImg.width*ratio, artImg.height*ratio);
            }
            ctx.fillStyle = 'rgba(0,0,0,0.3)';
            ctx.fillRect(0,0,3000,3000);
            const artist = document.getElementById('art-artist').value;
            const song = document.getElementById('art-song').value;
            ctx.textAlign = 'center';
            ctx.fillStyle = 'white';
            ctx.font = 'bold 200px sans-serif';
            ctx.fillText(artist.toUpperCase(), 1500, 1400);
            ctx.font = 'italic 150px serif';
            ctx.fillText(song, 1500, 1700);
            const pCtx = artPreview.getContext('2d');
            artPreview.width=500; artPreview.height=500;
            pCtx.drawImage(artCanvas, 0,0,3000,3000,0,0,500,500);
        }
        function downloadArt() {
            const link = document.createElement('a');
            link.download = 'Cover_Art_3000.jpg';
            link.href = artCanvas.toDataURL('image/jpeg', 0.9);
            link.click();
        }
    </script>
</body>
</html>



