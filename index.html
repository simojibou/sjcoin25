<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>SJ Random Video Chat</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Cairo:wght@400;600;800&display=swap" rel="stylesheet">
  <style>
    body { font-family: 'Cairo', system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, 'Helvetica Neue', Arial; }
    /* Ensure videos fill their containers properly */
    video { width: 100%; height: 100%; object-fit: cover; }
    /* Custom glass effect for better readability */
    .glass { backdrop-filter: blur(12px) saturate(150%); background: rgba(0,0,0,0.25); }
    .btn-disabled { opacity: 0.4; cursor: not-allowed; }
  </style>
</head>
<body class="min-h-screen bg-slate-900 text-white flex items-center justify-center p-4">

  <main class="w-full max-w-md mx-auto aspect-[9/16] rounded-3xl overflow-hidden shadow-2xl bg-slate-800 relative ring-1 ring-white/10">

    <video id="remoteVideo" autoplay playsinline class="absolute top-0 left-0 w-full h-full bg-slate-800"></video>

    <header class="absolute top-0 left-0 right-0 p-4 flex justify-between items-center z-10">
      <h1 class="text-xl font-bold text-shadow">SJ<span class="text-indigo-300">Chat</span></h1>
      <div id="status" class="text-sm font-semibold px-3 py-1 rounded-full glass">ğŸŸ¡ ÙÙŠ Ø§Ù„Ø¥Ù†ØªØ¸Ø§Ø±</div>
    </header>

    <div class="absolute top-20 right-4 w-1/4 aspect-[9/16] rounded-2xl overflow-hidden shadow-lg ring-1 ring-white/20 z-10 glass">
      <video id="localVideo" autoplay playsinline muted></video>
    </div>

    <div class="absolute bottom-0 left-0 right-0 p-4 z-10">
      <div class="flex items-center justify-center space-i-3 glass rounded-full p-2">
        <button id="btnStart" class="w-16 h-16 rounded-full bg-indigo-500 hover:bg-indigo-600 transition font-semibold flex items-center justify-center text-3xl">â–¶ï¸</button>
        <button id="btnNext" class="w-20 h-20 rounded-full bg-emerald-500 hover:bg-emerald-600 transition font-bold flex items-center justify-center text-lg btn-disabled" disabled>Ø§Ù„ØªØ§Ù„ÙŠ</button>
        <button id="btnHangup" class="w-16 h-16 rounded-full bg-rose-500 hover:bg-rose-600 transition font-semibold flex items-center justify-center text-3xl btn-disabled" disabled>â¹ï¸</button>
      </div>
    </div>
  </main>

  <script src="https://www.gstatic.com/firebasejs/10.12.5/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.12.5/firebase-firestore-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.12.5/firebase-auth-compat.js"></script>
  
  <script>
    // --- 1. FIREBASE CONFIGURATION ---
    const firebaseConfig = {
      // IMPORTANT: Replace with your own Firebase project configuration
      apiKey: "AIzaSyCw46Dkka-64h7Rc3VIS9fZmvrfvbUCTjY",
      authDomain: "metawarefare-gaming.firebaseapp.com",
      databaseURL: "https://metawarefare-gaming-default-rtdb.firebaseio.com",
      projectId: "metawarefare-gaming",
      storageBucket: "metawarefare-gaming.appspot.com",
      messagingSenderId: "551352148152",
      appId: "1:551352148152:web:1b8fe7257e19fba720d44d"
    };

    // --- 2. INITIALIZE FIREBASE & WEBRTC ---
    firebase.initializeApp(firebaseConfig);
    const firestore = firebase.firestore();
    const auth = firebase.auth();

    // WebRTC configuration - using a public STUN server
    const servers = {
      iceServers: [
        {
          urls: ['stun:stun1.l.google.com:19302', 'stun:stun2.l.google.com:19302'],
        },
      ],
      iceCandidatePoolSize: 10,
    };

    let pc = new RTCPeerConnection(servers);
    let localStream = null;
    let remoteStream = null;
    let currentRoomId = null;
    let roomListener = null; // To unsubscribe from Firestore listener

    // --- 3. DOM ELEMENTS ---
    const localVideo = document.getElementById('localVideo');
    const remoteVideo = document.getElementById('remoteVideo');
    const btnStart = document.getElementById('btnStart');
    const btnNext = document.getElementById('btnNext');
    const btnHangup = document.getElementById('btnHangup');
    const statusDiv = document.getElementById('status');

    // --- 4. CORE FUNCTIONS ---

    /**
     * Starts the camera and microphone, displaying the stream locally.
     */
    const startCamera = async () => {
      try {
        localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
        localVideo.srcObject = localStream;
        remoteStream = new MediaStream();
        remoteVideo.srcObject = remoteStream;
        
        updateUI('camera_on');
        console.log('Camera and mic started');
      } catch (error) {
        console.error('Error starting camera:', error);
        alert('Ù„Ø§ ÙŠÙ…ÙƒÙ† Ø§Ù„ÙˆØµÙˆÙ„ Ø¥Ù„Ù‰ Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§ Ø£Ùˆ Ø§Ù„Ù…Ø§ÙŠÙƒØ±ÙˆÙÙˆÙ†. Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø§Ù„ØªØ£ÙƒØ¯ Ù…Ù† Ø§Ù„Ø£Ø°ÙˆÙ†Ø§Øª.');
      }
    };

    /**
     * Finds a waiting room or creates a new one to start a chat.
     */
    const findNextMatch = async () => {
      if (!localStream) {
        alert('Ø§Ù„Ø±Ø¬Ø§Ø¡ ØªØ´ØºÙŠÙ„ Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§ Ø£ÙˆÙ„Ø§Ù‹!');
        return;
      }

      await hangup(); // End any previous call
      updateUI('searching');

      const roomsRef = firestore.collection('rooms');
      // Look for a room that is waiting for someone to join
      const query = roomsRef.where('waiting', '==', true).limit(1);
      const snapshot = await query.get();

      if (snapshot.empty) {
        // No waiting rooms, so create a new one
        await createRoom();
      } else {
        // Found a waiting room, join it
        const roomDoc = snapshot.docs[0];
        currentRoomId = roomDoc.id;
        await joinRoom(roomDoc.id, roomDoc.data());
      }
    };

    /**
     * Creates a new chat room in Firestore and waits for a callee.
     */
    const createRoom = async () => {
      console.log('Creating a new room...');
      const roomRef = firestore.collection('rooms').doc();
      currentRoomId = roomRef.id;

      // Initialize the peer connection and get local tracks
      pc = new RTCPeerConnection(servers);
      addLocalTracks(pc);
      
      // Collect ICE candidates
      const callerCandidatesCollection = roomRef.collection('callerCandidates');
      pc.onicecandidate = event => {
        if (event.candidate) {
          callerCandidatesCollection.add(event.candidate.toJSON());
        }
      };
      
      // Create an offer
      const offer = await pc.createOffer();
      await pc.setLocalDescription(offer);

      const roomWithOffer = {
        offer: {
          type: offer.type,
          sdp: offer.sdp,
        },
        waiting: true, // Mark this room as waiting for a partner
        createdAt: firebase.firestore.FieldValue.serverTimestamp()
      };
      await roomRef.set(roomWithOffer);

      // Listen for the callee's answer
      listenForAnswer(roomRef);
    };

    /**
     * Joins an existing room and answers the call.
     */
    const joinRoom = async (roomId, roomData) => {
      console.log(`Joining room: ${roomId}`);
      const roomRef = firestore.collection('rooms').doc(roomId);

      // Mark the room as no longer waiting
      await roomRef.update({ waiting: false });

      pc = new RTCPeerConnection(servers);
      addLocalTracks(pc);

      // Collect ICE candidates
      const calleeCandidatesCollection = roomRef.collection('calleeCandidates');
      pc.onicecandidate = event => {
        if (event.candidate) {
          calleeCandidatesCollection.add(event.candidate.toJSON());
        }
      };

      // Set remote description from the offer
      await pc.setRemoteDescription(new RTCSessionDescription(roomData.offer));
      
      // Create an answer
      const answer = await pc.createAnswer();
      await pc.setLocalDescription(answer);

      const roomWithAnswer = {
        answer: {
          type: answer.type,
          sdp: answer.sdp,
        }
      };
      await roomRef.update(roomWithAnswer);
      
      // Listen for the caller's ICE candidates
      listenForIceCandidates(roomRef, 'callerCandidates');
      listenForRemoteStream();
    };
    
    /**
     * Caller-side function to listen for the callee's answer.
     */
    function listenForAnswer(roomRef) {
      roomListener = roomRef.onSnapshot(async snapshot => {
        const data = snapshot.data();
        if (!pc.currentRemoteDescription && data?.answer) {
          console.log('Got remote answer');
          const answerDescription = new RTCSessionDescription(data.answer);
          await pc.setRemoteDescription(answerDescription);
          updateUI('connected');
        }
      });
      listenForIceCandidates(roomRef, 'calleeCandidates');
      listenForRemoteStream();
    }

    /**
     * Listens for ICE candidates from the other peer.
     */
    function listenForIceCandidates(roomRef, collectionName) {
      roomRef.collection(collectionName).onSnapshot(snapshot => {
        snapshot.docChanges().forEach(async change => {
          if (change.type === 'added') {
            let data = change.doc.data();
            await pc.addIceCandidate(new RTCIceCandidate(data));
            console.log(`Added ${collectionName} ICE candidate`);
          }
        });
      });
    }

    /**
     * Adds local media tracks to the peer connection.
     */
    function addLocalTracks(peerConnection) {
        localStream.getTracks().forEach(track => {
            peerConnection.addTrack(track, localStream);
        });
    }

    /**
     * Listens for the remote media stream.
     */
    function listenForRemoteStream() {
        pc.ontrack = event => {
            console.log('Got remote track');
            event.streams[0].getTracks().forEach(track => {
                remoteStream.addTrack(track);
            });
            updateUI('connected');
        };
    }

    /**
     * Ends the call, closes connections, and cleans up the database.
     */
    const hangup = async () => {
      if (localStream) {
        localStream.getTracks().forEach(track => track.stop());
      }
      if (pc) {
        pc.close();
      }

      // Clean up the UI
      localVideo.srcObject = null;
      remoteVideo.srcObject = null;

      // Unsubscribe from Firestore listener to prevent memory leaks
      if (roomListener) {
        roomListener();
        roomListener = null;
      }
      
      // Delete the room from Firestore if it exists
      if (currentRoomId) {
        const roomRef = firestore.collection('rooms').doc(currentRoomId);
        // Delete subcollections first
        const callerCandidates = await roomRef.collection('callerCandidates').get();
        callerCandidates.forEach(async doc => await doc.ref.delete());
        const calleeCandidates = await roomRef.collection('calleeCandidates').get();
        calleeCandidates.forEach(async doc => await doc.ref.delete());
        // Delete the room document
        await roomRef.delete();
        console.log(`Deleted room: ${currentRoomId}`);
      }

      currentRoomId = null;
      pc = new RTCPeerConnection(servers); // Reset the connection object
      updateUI('initial');
    };

    /**
     * Updates the UI buttons and status based on the app's state.
     */
    function updateUI(state) {
        switch (state) {
            case 'initial':
                btnStart.classList.remove('btn-disabled');
                btnNext.classList.add('btn-disabled');
                btnHangup.classList.add('btn-disabled');
                btnStart.disabled = false;
                btnNext.disabled = true;
                btnHangup.disabled = true;
                statusDiv.textContent = 'ğŸ”´ ØºÙŠØ± Ù…ØªØµÙ„';
                break;
            case 'camera_on':
                btnStart.classList.add('btn-disabled');
                btnNext.classList.remove('btn-disabled');
                btnHangup.classList.add('btn-disabled');
                btnStart.disabled = true;
                btnNext.disabled = false;
                btnHangup.disabled = true;
                statusDiv.textContent = 'ğŸŸ¢ Ø¬Ø§Ù‡Ø²';
                break;
            case 'searching':
                btnHangup.classList.remove('btn-disabled');
                btnHangup.disabled = false;
                btnNext.disabled = true; // Disable "Next" while searching
                statusDiv.textContent = 'ğŸ” Ø¬Ø§Ø±ÙŠ Ø§Ù„Ø¨Ø­Ø«...';
                break;
            case 'connected':
                btnNext.classList.remove('btn-disabled');
                btnHangup.classList.remove('btn-disabled');
                btnNext.disabled = false;
                btnHangup.disabled = false;
                statusDiv.textContent = 'âœ… Ù…ØªØµÙ„';
                break;
        }
    }

    // --- 5. EVENT LISTENERS ---
    btnStart.onclick = startCamera;
    btnNext.onclick = findNextMatch;
    btnHangup.onclick = hangup;
    
    // Auto-sign in anonymously when the app loads
    auth.signInAnonymously().then(() => {
        console.log('Signed in anonymously.');
        updateUI('initial');
    }).catch(error => {
        console.error('Anonymous sign-in failed:', error);
        alert('ÙØ´Ù„ ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„. ÙŠØ±Ø¬Ù‰ ØªØ­Ø¯ÙŠØ« Ø§Ù„ØµÙØ­Ø©.');
    });
  </script>
</body>
</html>
