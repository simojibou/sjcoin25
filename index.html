<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>SJ Random Video Chat</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Cairo:wght@400;600;800&display=swap" rel="stylesheet">
  <style>
    body { font-family: 'Cairo', system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, 'Helvetica Neue', Arial; }
    video { width: 100%; height: 100%; object-fit: cover; }
    .glass { backdrop-filter: blur(12px) saturate(150%); background: rgba(0,0,0,0.25); }
    .btn-disabled { opacity: 0.4; cursor: not-allowed; }
  </style>
</head>
<body class="min-h-screen bg-slate-900 text-white flex items-center justify-center p-4">

  <main class="w-full max-w-md mx-auto aspect-[9/16] rounded-3xl overflow-hidden shadow-2xl bg-slate-800 relative ring-1 ring-white/10">

    <video id="remoteVideo" autoplay playsinline class="absolute top-0 left-0 w-full h-full bg-slate-800"></video>

    <header class="absolute top-0 left-0 right-0 p-4 flex justify-between items-center z-10">
      <h1 class="text-xl font-bold text-shadow">SJ<span class="text-indigo-300">Chat</span></h1>
      <div id="status" class="text-sm font-semibold px-3 py-1 rounded-full glass">ğŸŸ¡ ÙÙŠ Ø§Ù„Ø¥Ù†ØªØ¸Ø§Ø±</div>
    </header>

    <div class="absolute top-20 right-4 w-1/4 aspect-[9/16] rounded-2xl overflow-hidden shadow-lg ring-1 ring-white/20 z-10 glass">
      <video id="localVideo" autoplay playsinline muted></video>
    </div>

    <div class="absolute bottom-0 left-0 right-0 p-4 z-10">
      <div class="flex items-center justify-center space-i-3 glass rounded-full p-2">
        <button id="btnStart" class="w-16 h-16 rounded-full bg-indigo-500 hover:bg-indigo-600 transition font-semibold flex items-center justify-center text-3xl">â–¶ï¸</button>
        <button id="btnNext" class="w-20 h-20 rounded-full bg-emerald-500 hover:bg-emerald-600 transition font-bold flex items-center justify-center text-lg btn-disabled" disabled>Ø§Ù„ØªØ§Ù„ÙŠ</button>
        <button id="btnHangup" class="w-16 h-16 rounded-full bg-rose-500 hover:bg-rose-600 transition font-semibold flex items-center justify-center text-3xl btn-disabled" disabled>â¹ï¸</button>
      </div>
    </div>
  </main>

  <script src="https://www.gstatic.com/firebasejs/10.12.5/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.12.5/firebase-firestore-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.12.5/firebase-auth-compat.js"></script>
  
  <script>
    // --- 1. FIREBASE CONFIGURATION ---
    const firebaseConfig = {
      // IMPORTANT: Replace with your own Firebase project configuration
      apiKey: "AIzaSyCw46Dkka-64h7Rc3VIS9fZmvrfvbUCTjY",
      authDomain: "metawarefare-gaming.firebaseapp.com",
      databaseURL: "https://metawarefare-gaming-default-rtdb.firebaseio.com",
      projectId: "metawarefare-gaming",
      storageBucket: "metawarefare-gaming.appspot.com",
      messagingSenderId: "551352148152",
      appId: "1:551352148152:web:1b8fe7257e19fba720d44d"
    };

    // --- 2. INITIALIZE FIREBASE & WEBRTC ---
    firebase.initializeApp(firebaseConfig);
    const firestore = firebase.firestore();
    const auth = firebase.auth();

    const servers = {
      iceServers: [
        {
          urls: ['stun:stun1.l.google.com:19302', 'stun:stun2.l.google.com:19302'],
        },
      ],
      iceCandidatePoolSize: 10,
    };

    let pc = new RTCPeerConnection(servers);
    let localStream = null;
    let remoteStream = null;
    let currentRoomId = null;
    let roomListener = null; 
    let iceCandidateListener = null; // MODIFICATION: To unsubscribe from ICE listener
    let cachedIceCandidates = []; // MODIFICATION: Buffer for ICE candidates

    // --- 3. DOM ELEMENTS ---
    const localVideo = document.getElementById('localVideo');
    const remoteVideo = document.getElementById('remoteVideo');
    const btnStart = document.getElementById('btnStart');
    const btnNext = document.getElementById('btnNext');
    const btnHangup = document.getElementById('btnHangup');
    const statusDiv = document.getElementById('status');

    // --- 4. CORE FUNCTIONS ---

    const startCamera = async () => {
      try {
        localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
        localVideo.srcObject = localStream;
        remoteStream = new MediaStream();
        remoteVideo.srcObject = remoteStream;
        
        updateUI('camera_on');
        console.log('Camera and mic started');
      } catch (error) {
        console.error('Error starting camera:', error);
        alert('Ù„Ø§ ÙŠÙ…ÙƒÙ† Ø§Ù„ÙˆØµÙˆÙ„ Ø¥Ù„Ù‰ Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§ Ø£Ùˆ Ø§Ù„Ù…Ø§ÙŠÙƒØ±ÙˆÙÙˆÙ†. Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø§Ù„ØªØ£ÙƒØ¯ Ù…Ù† Ø§Ù„Ø£Ø°ÙˆÙ†Ø§Øª.');
      }
    };

    const findNextMatch = async () => {
      if (!localStream) {
        alert('Ø§Ù„Ø±Ø¬Ø§Ø¡ ØªØ´ØºÙŠÙ„ Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§ Ø£ÙˆÙ„Ø§Ù‹!');
        return;
      }
      await hangup(); 
      updateUI('searching');
      const roomsRef = firestore.collection('rooms');
      const query = roomsRef.where('waiting', '==', true).limit(1);
      const snapshot = await query.get();

      if (snapshot.empty) {
        await createRoom();
      } else {
        const roomDoc = snapshot.docs[0];
        currentRoomId = roomDoc.id;
        await joinRoom(roomDoc.id, roomDoc.data());
      }
    };

    const createRoom = async () => {
      console.log('Creating a new room...');
      const roomRef = firestore.collection('rooms').doc();
      currentRoomId = roomRef.id;

      initializePeerConnection(); // MODIFICATION: Use helper function
      
      const callerCandidatesCollection = roomRef.collection('callerCandidates');
      pc.onicecandidate = event => {
        if (event.candidate) {
          callerCandidatesCollection.add(event.candidate.toJSON());
        }
      };
      
      const offer = await pc.createOffer();
      await pc.setLocalDescription(offer);
      const roomWithOffer = {
        offer: { type: offer.type, sdp: offer.sdp },
        waiting: true,
        createdAt: firebase.firestore.FieldValue.serverTimestamp()
      };
      await roomRef.set(roomWithOffer);
      listenForAnswer(roomRef);
    };

    const joinRoom = async (roomId, roomData) => {
      console.log(`Joining room: ${roomId}`);
      const roomRef = firestore.collection('rooms').doc(roomId);
      await roomRef.update({ waiting: false });

      initializePeerConnection(); // MODIFICATION: Use helper function

      const calleeCandidatesCollection = roomRef.collection('calleeCandidates');
      pc.onicecandidate = event => {
        if (event.candidate) {
          calleeCandidatesCollection.add(event.candidate.toJSON());
        }
      };

      await pc.setRemoteDescription(new RTCSessionDescription(roomData.offer));
      
      const answer = await pc.createAnswer();
      await pc.setLocalDescription(answer);
      const roomWithAnswer = {
        answer: { type: answer.type, sdp: answer.sdp }
      };
      await roomRef.update(roomWithAnswer);
      
      listenForIceCandidates(roomRef, 'callerCandidates');
    };
    
    function listenForAnswer(roomRef) {
      roomListener = roomRef.onSnapshot(async snapshot => {
        const data = snapshot.data();
        if (!pc.currentRemoteDescription && data?.answer) {
          console.log('Got remote answer, setting remote description.');
          try {
            const answerDescription = new RTCSessionDescription(data.answer);
            await pc.setRemoteDescription(answerDescription);
            await processCachedIceCandidates(); // MODIFICATION: Process any buffered candidates
          } catch (e) {
            console.error("Error setting remote description: ", e);
          }
        }
      });
      listenForIceCandidates(roomRef, 'calleeCandidates');
    }

    /**
     * MODIFICATION: Robust ICE candidate handling with buffering.
     */
    function listenForIceCandidates(roomRef, collectionName) {
      iceCandidateListener = roomRef.collection(collectionName).onSnapshot(snapshot => {
        snapshot.docChanges().forEach(async change => {
          if (change.type === 'added') {
            const candidate = new RTCIceCandidate(change.doc.data());
            try {
              if (pc.remoteDescription) {
                // If remote description is set, add candidate directly
                await pc.addIceCandidate(candidate);
                console.log(`Added ICE candidate immediately.`);
              } else {
                // Otherwise, buffer it
                cachedIceCandidates.push(candidate);
                console.log(`Cached an ICE candidate.`);
              }
            } catch (e) {
              console.error('Error adding received ICE candidate', e);
            }
          }
        });
      });
    }

    /**
     * MODIFICATION: Helper function to process buffered candidates.
     */
    async function processCachedIceCandidates() {
        console.log(`Processing ${cachedIceCandidates.length} cached candidates.`);
        for (const candidate of cachedIceCandidates) {
            try {
                await pc.addIceCandidate(candidate);
                console.log(`Added a cached ICE candidate.`);
            } catch (e) {
                console.error("Error adding cached candidate: ", e);
            }
        }
        cachedIceCandidates = []; // Clear the cache
    }

    /**
     * MODIFICATION: Centralized peer connection setup
     */
    function initializePeerConnection() {
      pc = new RTCPeerConnection(servers);
      addLocalTracks(pc);
      
      // Listen for remote tracks
      pc.ontrack = event => {
        console.log('âœ… Got remote track!');
        event.streams[0].getTracks().forEach(track => {
          remoteStream.addTrack(track);
        });
      };

      // MODIFICATION: Listen for connection state changes for debugging
      pc.oniceconnectionstatechange = () => {
        console.log(`ICE connection state: ${pc.iceConnectionState}`);
        if (pc.iceConnectionState === 'connected' || pc.iceConnectionState === 'completed') {
            updateUI('connected');
        } else if (pc.iceConnectionState === 'failed') {
            console.error('Connection failed. Restarting ICE...');
            pc.restartIce(); // Attempt to recover
        }
      };
    }
    
    function addLocalTracks(peerConnection) {
        localStream.getTracks().forEach(track => {
            peerConnection.addTrack(track, localStream);
        });
    }

    const hangup = async () => {
      if (pc) {
        pc.close();
      }
      
      // MODIFICATION: Unsubscribe from all listeners
      if (roomListener) { roomListener(); roomListener = null; }
      if (iceCandidateListener) { iceCandidateListener(); iceCandidateListener = null; }

      if (currentRoomId) {
        const roomRef = firestore.collection('rooms').doc(currentRoomId);
        const callerCandidates = await roomRef.collection('callerCandidates').get();
        callerCandidates.forEach(async doc => await doc.ref.delete());
        const calleeCandidates = await roomRef.collection('calleeCandidates').get();
        calleeCandidates.forEach(async doc => await doc.ref.delete());
        await roomRef.delete();
      }

      // Reset state
      if (localStream) {
        localStream.getTracks().forEach(track => track.stop());
        localStream = null;
      }
      localVideo.srcObject = null;
      remoteVideo.srcObject = null;
      currentRoomId = null;
      cachedIceCandidates = []; // MODIFICATION: Clear cache on hangup

      updateUI('initial');
    };

    function updateUI(state) {
        // UI update logic remains the same
        switch (state) {
            case 'initial':
                btnStart.classList.remove('btn-disabled');
                btnNext.classList.add('btn-disabled');
                btnHangup.classList.add('btn-disabled');
                btnStart.disabled = false;
                btnNext.disabled = true;
                btnHangup.disabled = true;
                statusDiv.textContent = 'ğŸ”´ ØºÙŠØ± Ù…ØªØµÙ„';
                break;
            case 'camera_on':
                btnStart.classList.add('btn-disabled');
                btnNext.classList.remove('btn-disabled');
                btnHangup.classList.add('btn-disabled');
                btnStart.disabled = true;
                btnNext.disabled = false;
                btnHangup.disabled = true;
                statusDiv.textContent = 'ğŸŸ¢ Ø¬Ø§Ù‡Ø²';
                break;
            case 'searching':
                btnHangup.classList.remove('btn-disabled');
                btnHangup.disabled = false;
                btnNext.disabled = true;
                statusDiv.textContent = 'ğŸ” Ø¬Ø§Ø±ÙŠ Ø§Ù„Ø¨Ø­Ø«...';
                break;
            case 'connected':
                btnNext.classList.remove('btn-disabled');
                btnHangup.classList.remove('btn-disabled');
                btnNext.disabled = false;
                btnHangup.disabled = false;
                statusDiv.textContent = 'âœ… Ù…ØªØµÙ„';
                break;
        }
    }

    // --- 5. EVENT LISTENERS & INITIALIZATION ---
    btnStart.onclick = startCamera;
    btnNext.onclick = findNextMatch;
    btnHangup.onclick = hangup;
    
    auth.signInAnonymously().then(() => {
        console.log('Signed in anonymously.');
        updateUI('initial');
    }).catch(error => {
        console.error('Anonymous sign-in failed:', error);
        alert('ÙØ´Ù„ ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„. ÙŠØ±Ø¬Ù‰ ØªØ­Ø¯ÙŠØ« Ø§Ù„ØµÙØ­Ø©.');
    });
  </script>
</body>
</html>
